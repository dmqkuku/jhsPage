
Item3. 이어서
저자에 따르면 단일 element를 가진 enum 타입이 singleton 구현하기에 최고라고 한다.


Item4. Enforce noninstaniablity with a private constructor
보통 Util static method를 모아놓은 클래스는 bad practice로 인식된다.(나도 그렇게 생각)
그치만 저자에 따르면, 이러한 클래스가 쓸모 있는 경우도 있다고 한다. 
final class MyUtils {
    public static void doSomething(){

    }
}
final을 붙여 상속을 막는 것과 함께.
이런 클래스는 인스턴스화도 방지되어야 한다. <- 왜?. 뭐 인스턴스화 해도 쓸모는 없을 텐데? 어처피 static 메소드들만 모아놓았다며,

"인스턴스화 방지를 위해" 추상 클래스로 만들어봣자임
해당 클래스는 자식 클래스를 가질 수 있고, 자식 클래스는 인스턴스화 할 수 있기 때문임.
게다가 다른 사용자가 클래스를 보고서 "아 가상 클래스니까 상속하면 되겠구나?" 라고 생각하기 쉬움.

이거 private constructor 만드는 거는 너무 기본이라 넘어가려고 했슴.
작가가 의도한 것은 public 생성자 호출에 의한 인스턴스화를 막으려는 것 같음. 
애초에 private 생성자로 해도 팩토리 메소드를 쓰면 인스턴스화가 가능하잖슴.
그냥 클래스 내에서 인스턴스화 해서 리턴할 수 있고...

Item5. Prefer dependency Injection to hardwiring resources. <- Spring이 생각나네.
DI와 Hardwiring 은 유명.
hardWiring은 
private Meat patties = new Meat();
이렇게 박아넣거나. 하는 거임...
예전에는 DI가 좋다 좋다. hardwiring은 안좋다. 이유는 모듈성이 안좋아진다, 코드 보수하기 힘들다~ 같은 것들이 있었다.


가장 간단한 DI는 주입할 자원을 생성자에게 넘기는 형태이다.
또다른 형태는 자원 factory를 넘기는 형태이다.
일일히 DI 만드는 작업은 작은 프로젝트에선 유효할 지도 모르지만, 프로젝트 규모가 커지면 clutter를 일으킬 수 있당.
->Spring이 대두된 이유.

Item6. Avoid Creting unnecessary objects

생성자는 반드시 호출될 때 객체를 찍어내줘야 하지만, factory method는 그럴 필요 없다. 즉 같은 인스턴스 계속 
