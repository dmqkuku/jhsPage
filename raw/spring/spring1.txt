BeanFactory
스프링 IOC의 최상위
빈 설정 소스로부터 빈 정의를 읽어들여 구성하고 제공. 기본적으로 singleton scope으로 생성된다. (bean annotation이나 설정 외에 따로 설정이 없다면.)
그렇다면 싱글톤이 아닌 경우도 존재 : 프로토타입. 
프로토 타입: 매번 다른 객체가 사용됨.
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html

Bean 이란 스프링 IOC 컨테이너가 관리하는 객체.
!= JavaBean

//하나의 BeanScope에서 하나의 Bean.

프로토타입에 비하여. 싱글톤은 런타임시 성능 최적화에 유리하다.
라이프 사이클 인터페이스 지원.. -> 예제. @PostConstruct

장점 1. 스코프
장점 2. 의존성 관리
장점 3. 라이프 사이클 인터페이스 

//assertThat?
//https://jwkim96.tistory.com/168 assertj vs junit


## application Context

//https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html

BeanFactory의 구현체.

//@Component
-> @Service
-> @Repository

DI는 자동으로 되지 않고.
@Autowired

혹은

@Inject(다른 의존성이 필요하당.)

Annotation 기반 == 2.5 부터

Java Configuration... 

@ComponentScan(basePackageClass = DummyConfig.class) -> DummyConfig가 있는 곳부터 스캔~
DummyConfig

@AutoWired...
required true가 기본값으로. 못찾을경우 구동 실패
** 생성자에서 autowire 실패하여 구동 실패와 달리 setter에 autowire할 경우. 인스턴스 자체는 만들 수 있다.
만약 이 DI가 필수가 아니라면, required=false 명시.

생성자 (스프링 4.3 부터 생략 가능???)
셋터
필드

1. 해당 타입의 빈이 없을 경우
2. 해당 타입의 빈이 한개일 경우
3. 해당 타입의 빈이 여러개일 경우 -> 기본적으로 실패!
    3-1. 빈 이름으로 시도
        3-1-1. 같은 이름 빈 있으면 해당 빈 사용
        3-1-2. 같은 이름 못 찾으면 실패

Action:
Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed

같은 타입 빈이 여럿일 경우
@Primary -> 추가적으로 @Primary 적힌 빈을 넣어줌. -> **@Primary가 여럿이면?
해당 타입 빈 모두 주입받기
example
```java
    @Autowired
    List<Bean> beans;
```
@Qualifer(빈 이름으로 주입)


...Autowired는 타입보고, 이름도 본다.
예를들어 주입받을 빈이 
class MyBean이면

@Autowired
Bean myBean; 이렇게

->>>>> 안좋은 방법!!!! ** 왜?
[동작원리]

라이프 사이클 인터페이스 중 
BeanPostProccessor.
-> Bean 인스턴스 만든 후(instanciation). bean의 초기화(initialization) 라이프 사이클. 하기 전에 수행하는 
예:
-->>
@PostConsturct
혹은
아주 오래된 인터페이스 : InitializingBean
-->> 이 두개는 beanPostProcces다음에 실행.
실행 순서는 문서 맨 위 스프링api 문서의 BeanFactory 항목 찾아볼 것.  

BeanFactory가 자기 안에 등록된 BeanPostProccessor를 찾아서 일반적인 Bean들에게  BeanPostProccessor안의 로직을 적용함.

그냥 실행시킬때
주입받아 버리거나
applciationContext로 꺼내서 열어보장~

---------------------------------------------------------------------------------------------------------------------

@Component와 컴포넌트 스캔...
@ComponentScan -> 3.1버전부터.
               -> 중요속성1 : 같은 패키지와 그 하위 패키지...
               -> 중요속성2 : 특정 타입을 걸러낼 수 있다...
               -> excludeFilters = TypeExcludeFilter/ AutoConfigurationExcludeFilter 

@Configuration -> @Component긴 한데... 


이하 Spring 5 && Java 10
----------------------------------------------------------------------------------------------------------------------
스프링 5부터. Function을 이용한 Bean 등록.
기존 Bean 등록 -> Reflection/ Proxy => overhead / Spring application 구동 시간의 차이...

Java 10부터 var local variable 사용가능.
```java
var app = new SpringApplication(DemoApplication.class);
app.addInitializer(new ApplicationContextInitializer<GeneratingApplicationContext> ctx => ctx.registBean("BeanName".class));
app.run(args)
```

```java
var app = new SpringApplication(DemoApplication.class);
app.addInitializer(new ApplicationContextInitializer<GeneratingApplicationContext> ctx => {
    ctx.registerBean("BeanName".class);
    ctx.registerBean(ApplicationRunner.class, () => args1 => System.out.println("Hi"));
});
app.run(args) 
```

=======================================================================================================================
빈의 스코프
=======================================================================================================================

기본적으로 singleton.

Request. Session. Websocket.

@Scope("prototype");

프로토타입 스콥의 빈이 싱글톤 빈을 사용하는 경우.
싱글톤 빈이 프로토타입 스콥의 빈을 사용하는 경우.   
    -> 매번 달라야 하는 프로토 타입 스콥의 특성이 싱글톤 빈에 주입된 property에 반영되지 않는다.
    -> 로그 찍어보면 매번 같당.
    -> 이 경우.
     @Scope(value="prototype", proxyMode = ScopeProxyMode.TARGET_CLASS) => 프록시로 감싸라 라고 지시할 것. -> 해당 빈이 프록시로 감싸여서 주입됨.
     @ScopeProxyMode.INTERFACE

** 기본적으로 Java JDK에서는 Proxy 로 인터페이스만 감쌀 수 있다고 함. 연구 필요. 즉 인터페이스 기반의 프록시만 가능.

    이는 Scoped-Proxy라고 함.
    -> 너무 복잡하고, 성능에 영향 줄듯 이라고 생각하면.

    또다른 방법 Object-provider 
    ```java
        @Autowired
        private ObjectProvider<Proto> proto;
    ```
    -> 백기선의 의견 : 스프링 코드를 프레임워크 외부에서 사용하는 것은 좋지 않다.


    표준은 Provider.

    **thread-safe; 간단히 이야기해서 값이 쓰기 가능하고, 동시에 복수 쓰레드에서 접근 가능한 시점에서 thread-safe하지 않다.


=======================================================================================================================
Environment
=======================================================================================================================

프로파일 - 일종의 환경 
ex) 테스트 환경에서는 ~~ 빈을 쓰겟따. 프로덕션 환경에서는 ~~ 빈을 쓰겟따.

Environment env = ctx.getEnvironment();
Environment.getActiveProfile();
Environment.getDefaultProfile();

bean 위에 @Profile("profile name")
이렇게.
예를들어 @Profile("test")

IDE에서 Active Profile을 설정해야 한다.

@Profile("!prod")
도 가능. prod가 아닐때...
& 와 | 도 가능하다.

--------------------------------------------------------------------------------------------------------------------------

Property...

계층형 접근임...

다양한 방법으로 접근할 수 있는 설정값.
Environment의 또다른 역할. 프로퍼티 값 가져오기

Environment env = new Environment();
env.getProperty();

프로퍼티 우선순위
    Servlet Config 매개변수
    Servlet Context 매개변수
    JNDI
    JVM 시스템 프로퍼티 
    JVM 시스템 환경변수

============================================================================================================================
Message Source
============================================================================================================================

국제화 i8n을 제공하는 인터페이스...

@Autowired
MessageSource messageSource;

messageSource.getMessage();

기본적으로 messageSource라는 빈이 message라는 번들을 읽고 있당

// 스프링이 기본적으로 쓰는 설정들을 우리가 맘대로 뜯어고칠 수 있당.

```java
@Bean
public MessageSource messageSource(){
    var messageSource = new ReloadableResourceBundleMessageSource(); -> 빌드를 해야 적용됨.
    messageSource.setBaseName();
    messageSource.setDefaultEncoding();
    .
    .
    .
}
```

================================================================================================================================
이벤트 프로그래밍...
================================================================================================================================

이벤트 클래스는 빈으로 등록될 필요 없다.
```java
class MyEvent extends ApplicationEvent{
    public MyEvent(){
        super();
    }
    .
    .
    .
}
```

Event handler는 빈으로 등록되어야 한다.

4.2 이전에는
implements ApplicationListener<MyEvent>

4.2 이후에는
implements 필요없구
handler 는 빈 등록 필요.
메서드 위에 @EventListener 이렇게 달아주면 된다.

같은 이벤트 처리하는 핸들러가 두개 있으면. 둘다 순차적으로 실행. 순서는? 모른다.
@Order(Ordered.HIGHEST_PRECEDENCE + 2) 이런것도 가능...

비동기적 실행-> @Async
-> 단 @Async 붙인다고 해서 무조건 비동기가 아니고. @EnableAsync 해야 한다. 

ContextRefreshEvent.
ContextStartedEvent.
ContextStoppedEvent.
ContextClosedEvent.
RequestHandledEvent.

====================================================================================================================================
Resource Loader
====================================================================================================================================

리소스를 읽어오는 인터페이스. 

ApplicationContext extends ResourceLoader
-> fs 에서 읽기
-> 클래스패스에서 읽기
-> URL
-> 상대/절대 경로

resourceLoader.getResource(문자열);

====================================================================================================================================
Resource 추상화
====================================================================================================================================

구글 쥬스?

org.springframework.core.io.Resource

java.net.URL을 추상화 한 것.
스프링 내부에서 많이 사용함.

추상화 이유:    URL은 클래스 패스 기반으로 가져오는 기능 부재
               상대 경로 읽는 기능 부재.
               편의 메서드가 부족.

FileSystemXmlApplicationContext 

ClassPathResource
FileSystemResource
URLResource
ServletContextResource

추천 :  ApplicationContext 타입에 상관없이 리소스 타입을 강제하려면. java.net.URL 접두어 중 하나를 사용할 수 있다.(classpath:, file: ...)

스프링 부트 내장 톰캣에는 context path가 지정되어 있지 않음. 


=======================================================================================================================================
Validation 추상화
=======================================================================================================================================

 http://beanValidation.org

 beanValidation == Java ee 표준 스펙 중 하나.

implements Validator

 support. -> 들어오는 메서드가 검증 가능한 클래스인지 검증하는 메서드
    SomeClass.class.equals(clazz);

 validate. -> 실제 검증하는 메서드.

 스프링에서 BeanPropertBindingResult를 자동으로 만들어서 넘겨줌...

 

 