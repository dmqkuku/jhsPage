BeanFactory
스프링 IOC의 최상위
빈 설정 소스로부터 빈 정의를 읽어들여 구성하고 제공. 기본적으로 singleton scope으로 생성된다. (bean annotation이나 설정 외에 따로 설정이 없다면.)
그렇다면 싱글톤이 아닌 경우도 존재 : 프로토타입. 
프로토 타입: 매번 다른 객체가 사용됨.
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html

Bean 이란 스프링 IOC 컨테이너가 관리하는 객체.
!= JavaBean

//하나의 BeanScope에서 하나의 Bean.

프로토타입에 비하여. 싱글톤은 런타임시 성능 최적화에 유리하다.
라이프 사이클 인터페이스 지원.. -> 예제. @PostConstruct

장점 1. 스코프
장점 2. 의존성 관리
장점 3. 라이프 사이클 인터페이스 

//assertThat?
//https://jwkim96.tistory.com/168 assertj vs junit


## application Context

//https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html

BeanFactory의 구현체.

//@Component
-> @Service
-> @Repository

DI는 자동으로 되지 않고.
@Autowired

혹은

@Inject(다른 의존성이 필요하당.)

Annotation 기반 == 2.5 부터

Java Configuration... 

@ComponentScan(basePackageClass = DummyConfig.class) -> DummyConfig가 있는 곳부터 스캔~
DummyConfig

@AutoWired...
required true가 기본값으로. 못찾을경우 구동 실패
** 생성자에서 autowire 실패하여 구동 실패와 달리 setter에 autowire할 경우. 인스턴스 자체는 만들 수 있다.
만약 이 DI가 필수가 아니라면, required=false 명시.

생성자 (스프링 4.3 부터 생략 가능???)
셋터
필드

1. 해당 타입의 빈이 없을 경우
2. 해당 타입의 빈이 한개일 경우
3. 해당 타입의 빈이 여러개일 경우 -> 기본적으로 실패!
    3-1. 빈 이름으로 시도
        3-1-1. 같은 이름 빈 있으면 해당 빈 사용
        3-1-2. 같은 이름 못 찾으면 실패

Action:
Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed

같은 타입 빈이 여럿일 경우
@Primary -> 추가적으로 @Primary 적힌 빈을 넣어줌. -> **@Primary가 여럿이면?
해당 타입 빈 모두 주입받기
example
```java
    @Autowired
    List<Bean> beans;
```
@Qualifer(빈 이름으로 주입)


...Autowired는 타입보고, 이름도 본다.
예를들어 주입받을 빈이 
class MyBean이면

@Autowired
Bean myBean; 이렇게

->>>>> 안좋은 방법!!!! ** 왜?
[동작원리]

라이프 사이클 인터페이스 중 
BeanPostProccessor.
-> Bean 인스턴스 만든 후(instanciation). bean의 초기화(initialization) 라이프 사이클. 하기 전에 수행하는 
예:
-->>
@PostConsturct
혹은
아주 오래된 인터페이스 : InitializingBean
-->> 이 두개는 beanPostProcces다음에 실행.
실행 순서는 문서 맨 위 스프링api 문서의 BeanFactory 항목 찾아볼 것.  

BeanFactory가 자기 안에 등록된 BeanPostProccessor를 찾아서 일반적인 Bean들에게  BeanPostProccessor안의 로직을 적용함.

그냥 실행시킬때
주입받아 버리거나
applciationContext로 꺼내서 열어보장~

---------------------------------------------------------------------------------------------------------------------

@Component와 컴포넌트 스캔...
@ComponentScan -> 3.1버전부터.
               -> 중요속성1 : 같은 패키지와 그 하위 패키지...
               -> 중요속성2 : 특정 타입을 걸러낼 수 있다...
               -> excludeFilters = TypeExcludeFilter/ AutoConfigurationExcludeFilter 

@Configuration -> @Component긴 한데... 


이하 Spring 5 && Java 10
----------------------------------------------------------------------------------------------------------------------
스프링 5부터. Function을 이용한 Bean 등록.
기존 Bean 등록 -> Reflection/ Proxy => overhead / Spring application 구동 시간의 차이...

Java 10부터 var local variable 사용가능.
```java
var app = new SpringApplication(DemoApplication.class);
app.addInitializer(new ApplicationContextInitializer<GeneratingApplicationContext> ctx => ctx.registBean("BeanName".class));
app.run(args)
```

```java
var app = new SpringApplication(DemoApplication.class);
app.addInitializer(new ApplicationContextInitializer<GeneratingApplicationContext> ctx => {
    ctx.registerBean("BeanName".class);
    ctx.registerBean(ApplicationRunner.class, () => args1 => System.out.println("Hi"));
});
app.run(args) 
```

=======================================================================================================================
빈의 스코프
=======================================================================================================================

기본적으로 singleton.

Request. Session. Websocket.

@Scope("prototype");

프로토타입 스콥의 빈이 싱글톤 빈을 사용하는 경우.
싱글톤 빈이 프로토타입 스콥의 빈을 사용하는 경우.   
    -> 매번 달라야 하는 프로토 타입 스콥의 특성이 싱글톤 빈에 주입된 property에 반영되지 않는다.
    -> 로그 찍어보면 매번 같당.
    -> 이 경우.
     @Scope(value="prototype", proxyMode = ScopeProxyMode.TARGET_CLASS) => 프록시로 감싸라 라고 지시할 것. -> 해당 빈이 프록시로 감싸여서 주입됨.
     @ScopeProxyMode.INTERFACE

** 기본적으로 Java JDK에서는 Proxy 로 인터페이스만 감쌀 수 있다고 함. 연구 필요. 즉 인터페이스 기반의 프록시만 가능.

    이는 Scoped-Proxy라고 함.
    -> 너무 복잡하고, 성능에 영향 줄듯 이라고 생각하면.

    또다른 방법 Object-provider 
    ```java
        @Autowired
        private ObjectProvider<Proto> proto;
    ```
    -> 백기선의 의견 : 스프링 코드를 프레임워크 외부에서 사용하는 것은 좋지 않다.


    표준은 Provider.

    **thread-safe; 간단히 이야기해서 값이 쓰기 가능하고, 동시에 복수 쓰레드에서 접근 가능한 시점에서 thread-safe하지 않다.


=======================================================================================================================
Environment
=======================================================================================================================


