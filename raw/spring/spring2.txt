토비의 스프링 3.1


프로젝트에 참여한 프로그래머는 모름지기 변화에 대비해야 한다. 이러한 변화는 구체적으로 여러가지 관심에 동시에 발생하지 않고. 하나의 point에 집중된 요구사항인 경우가 대부분이다.

그런데 한 point에 집중한 변화와 달리, 프로그래머가 변화에 대응하기 위해 매번 다수의 point을 수정해야 한다면? -> 시간과 정확도의 소실.

즉 우리가 미래(변화)에 대비하기 위해 현재 프로그래밍할 때 수행하여야 하는 입장은. 하나의 변화 요구사항이 하나의 point에 집중되게 하는 것으로.

"관심"이 같은 것 끼리 모으고, 다른 것은 떨어뜨리게 하게 하는 것이다.

-> 이것이 관심사의 분리이다. "Separation of Concern";

사고방식 : "현재 해당 기능을 사용하는 메서드의 수가 x개로 적다. 그러니 신경 끄자" 가 아니라 "해당 기능을 사용하는 메서드가 2000개라면?"...

원칙과 패턴...
1. 개방 폐쇄 원칙. Open-Closed Principle = OCP

클래스와 모듈은 확장에는 열려있고, 변경에는 닫혀 있어야 한다.
즉 대상 소스 코드를 직접 변경하지 않고도 기능을 확장할 수 있어야 한다.

**SOLID sucks?**

1-a. 높은 응집도와 낮은 결합도.
    => 응집도가 높다 : 모듈. 클래스가 하나의 책임/관심사에만 집중되어 있다.
        => 변화가 일어날 때. 해당 모듈에서 변하는 부분이 크다.

    => 결합도가 낮다 : 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직.
        => 느슨한 연결 : 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적으로 구성.

1-b. 전략 패턴 
    -> 자신의 기능 context에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꾸어 낄 수 있도록 디자인.


**IoC (Inversion of Control)**

보통의 java에서는 main()에서 부터 시작하여. 사용자가 스스로 어떤 객체를 사용할지. 어떻게 사용할 지 결정한다.

IoC 개념하에서. 사용자 및 오브젝트는 자신이 사용할 오브젝트를 스스로 선택하지도 않고, 생성하지도 않고, 어떻게 만들어지는지, 어디서 사용되는지 관심도 없다.

모든 제어 권한을 위임...

ex) Sevlet. -> servlet에는 main이 있는 것이 아니고, 사용자가 직접 servlet을 실행시킬 수 없고, 컨테이너가 적절한 시점에 오브젝트를 만들어 호출하게 된다.


프레임워크 vs 라이브러리

둘다 코드 뭉치이지만, 라이브러리는 사용자에 의해 사용되는 코드 뭉치이고,
프레임워크는 사용자의 코드가 프레임워크에의해 사용되게 된다.(다른 프레임워크에도 적용되는 개념인가?) -> 토비는, 프레임워크라고 불리려면 분명히 제어의 역전이 있어야 한다고 주장.

## Spring IoC
Spring의 IoC 객체 = bean factory
보통 bean factory를 확장한 application context를 주로 사용.


자바에서 동일성(identity, is identical?) 과 동등성(equality, is equivalent?)은 차이가 존재한다. 동일성은 ==로, 동등성은 equals로 비교.

** Jar vs War. **
Jar -> contains libraries, resources, accessories file...
War -> contains web application.

대규모 서버 환경에서. 요청이 올때마다 새로운 오브젝트 생성한다고 가정.
1 요청당 5개의 오브젝트 생성이 필요하고
초당 500요청정도만 온다면?
초당 2500개, 분당 150000개, 한 시간에 900만개.
-> 상당한 부담이 된다.
-> 대안으로 그동안 서블릿을 비롯한 "서비스 오브젝트" 개념을 사용해 왔다.(서블릿은 멀티스레드 환경에서 보통 싱글톤으로 돌아간다.??)

**싱글톤 패턴에 한계**
1. 생성자를 private으로
2. 생성된 싱글톤 오브젝트를 저장할 수 있는, 자신과 같은 타입의 스태틱 필드 정의
3. static factory method인 getInstance()(관습), 메서드가 최초로 호출되는 시점에 한번만 오브젝트가 만들어 지도록...
4. 한번 오브젝트가 만들어 진 후에는 getInstance가 호출 될 때. 만들어져있는 인스턴스를 넘겨준다.

한계 
1. private 생성자때문에 상속 불능.
2. 테스트하기 어렵다. 만들어 지는 방식이 제한적이라. mock 객체로 대체하기 어렵다.
3. 서버 환경(여러 클래스 로더 / 여러 JVM이 가능)한 환경에서 싱글톤 보장이 어렵다.
4. 싱글톤을 가져오는 메서드 getInstance는 public static이기 때문에. 일종의 전역 함수가 된다.

스프링은 singleton registry 사용.

서버에서 싱글톤 사용시 주의점
1. 기본적으로 여러 스레드가 번갈아가며 접근하여 사용할 수 있기 때문에. 싱글톤은 "**stateless**"하게 디자인되어야 한다.

DI. 의존관계 주입...
의존관계란?
-> 방향성이 있어야 한다. 누가 누구에게 의존한다. A -> B 는 A가 B에 의존한다.
즉 B가 변하면 A도 수정/추가되어야 한다.
즉 A가 변해도 B는 그 변화에 영향 받지 않는다.

코드에 박힌 형태로. 드러나는 의존관계외에도.
런타임 시에 오브젝트사이에 만들어지는 의존관계도 있다.

런차임 의존관계. 의존 오브젝트...

의존관계 주입이란?
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

스프링은 Dependency Lookup도 가능하다. -> 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.



**자바 스펙에서는 spring boot가 jar로 웹 어플리케이션 말아주는 것처럼 하라는 명세가 없다.**

 
