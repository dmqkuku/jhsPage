--------------------------------------------------------

Chap6. Enums and Annotations.

Item34. Use enums instead of int constants.
 -> int 상수를 거의 무조건 쓰지 말고. enum 사용하자~
 -> COOKIE_MAX_AGE 같은 것처럼 하나만 달랑 있으면 상수 사용하는게 나을수도.
 -> 그러나 Http Status Code 같은 경우에는 enum 쓰는게 낫다.

  int 상수의 단점 중 하나는. 서로 전혀 다른 논리적 카테고리에 속한 상수끼리 연산이 가능
  int 상수의 단점 중 하나는 printable string으로 바꿀 방법이 없다.

  "Java Enum : 각 Enum constant당 하나씩 인스턴스를 export하는 class" -> 일반화된 싱글톤임
  "Complie time safety" 보장해준다.

  rich enum type... <- 메서드, 필드 구현 가능.  <- 필드는 final이 된다. public일 수 있으나 private으로 두고, public accessor를 두는 게 낫다.

  enum을 top-level class로 구현하고. 만약 특정 class와 tight associated되어 있다면 member class로 해라~

  만약에 만약에 각 enum 상수마다 다른 동작을(method 구현) 보이도록 하고 싶다면
  ```
    public enum Opertaion {
        PLUS, MINUS;
        public double apply(double x, double y){
            switch(this){
                case PLUS:
                case MINUS:
            }
        }
    }
  ```
  이거 (fragile한 코드) 대신에

  ```
    public enum Operation{
        public abstract double apply(double x, double y);
        PLUS {
            public double apply(double x, double y){
                return x + y;
            }
        }
        .
        .
        .
    }
  ```
  이렇게 구현할 수 있다. constant-specific class body가 가능!!!
  <- constant-specific method implementations.이라고 부름

  enum type은 자동적으로 생성된 valueOf(String)메서드를 가져서. cosntant'name => constant 로 바꿔줌.
  만약에 enum type의 toString을 override한다면 fromString 메서드를 작성하는 것을 고려하자
  ```
    private static final Map<String, Operation> stringToEnum = 
        Stream.of(values()).collect(toMap(Object::toString, e->e)); //????

    public static Optional<Operation> fromString(String symbol){
        return Optional.ofNullable(StringToEnum.get(symbol))
    }
  ```

  이러한 구현의 단점 : enum 상수끼리 code 공유하기 어려워진다.

  Use enums any time you need a set of constants whose members are known at compile time.

Item35. Use Instance Fields Instead of Ordinals...

  모든 enum은 내재적으로 단일 int 값과 연관되어 있다.
  모든 enum은 Ordinal 메서드를 가지고 있다.
  이 ordinal메서드는 숫자 순서를 리턴하게 된다. 
  이를 abuse하려는 욕심이 생길 수 있다.
  ```
     public enum Ensemble{
         SOLO, DUET
         pubilc int numberOfMusicians{return ordinal() + 1;}
     }
  ```
총체적 난국. 만약 순서가 바뀌면 fragile!
대신 다음을 고려하라!
```
    public enum Ensemble{
        SOLO(1), DUET(2), Double_Quartet(8)
        private final int numberOfMusicians;
        Ensemble(int size) {this.numberOfMusicians = size;}
        pubilc int numberOfMusicians(){return numberOfMusicians;}
    }
```

Item36. Use EnumSet instead of bit fields.
```
    public class Text{
        public static final int STYLE_BOLD = 1 << 0;
        public static final int STYLE_ITALIC = 1 << 1;
        .
        .
        .
    }
    .
    .
    .
    text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```
int constant의 단점을 그대로 지닌다.
출력시 알아보기 힘들고? <- 이방식에 숙련된 사람에게는 문제 없을듯
모든 요소를 쉽게 iterate할 수 없다.
*애초에 자바에는 unsigned가 업구
API만들때. 최대 비트 수와 그에 따른 타입 종류를 파악해야 한다? <- int long. <- 어거지인듯.


->EnumSet사용하자. Set의 일종!
```
public class Text{
    public enum Style {BOLD, ITALIC, ...};
    public void applyStyles(Set<Styles) styles){...}
}
.
.
.
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

이건 좀 논란의 여지가 있을 듯.

Item37. Use EnumMap instead of ordinal indexing.
idea


