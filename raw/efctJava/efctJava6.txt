--------------------------------------------------------

Chap6. Enums and Annotations.

Item34. Use enums instead of int constants.
 -> int 상수를 거의 무조건 쓰지 말고. enum 사용하자~
 -> COOKIE_MAX_AGE 같은 것처럼 하나만 달랑 있으면 상수 사용하는게 나을수도.
 -> 그러나 Http Status Code 같은 경우에는 enum 쓰는게 낫다.

  int 상수의 단점 중 하나는. 서로 전혀 다른 논리적 카테고리에 속한 상수끼리 연산이 가능
  int 상수의 단점 중 하나는 printable string으로 바꿀 방법이 없다.

  "Java Enum : 각 Enum constant당 하나씩 인스턴스를 export하는 class" -> 일반화된 싱글톤임
  "Complie time safety" 보장해준다.

  rich enum type... <- 메서드, 필드 구현 가능.  <- 필드는 final이 된다. public일 수 있으나 private으로 두고, public accessor를 두는 게 낫다.

  enum을 top-level class로 구현하고. 만약 특정 class와 tight associated되어 있다면 member class로 해라~

  만약에 만약에 각 enum 상수마다 다른 동작을(method 구현) 보이도록 하고 싶다면
  ```
    public enum Opertaion {
        PLUS, MINUS;
        public double apply(double x, double y){
            switch(this){
                case PLUS:
                case MINUS:
            }
        }
    }
  ```
  이거 (fragile한 코드) 대신에

  ```
    public enum Operation{
        public abstract double apply(double x, double y);
        PLUS {
            public double apply(double x, double y){
                return x + y;
            }
        }
        .
        .
        .
    }
  ```
  이렇게 구현할 수 있다. constant-specific class body가 가능!!!
  <- constant-specific method implementations.이라고 부름

  enum type은 자동적으로 생성된 valueOf(String)메서드를 가져서. cosntant'name => constant 로 바꿔줌.
  만약에 enum type의 toString을 override한다면 fromString 메서드를 작성하는 것을 고려하자
  ```
    private static final Map<String, Operation> stringToEnum = 
        Stream.of(values()).collect(toMap(Object::toString, e->e)); //????

    public static Optional<Operation> fromString(String symbol){
        return Optional.ofNullable(StringToEnum.get(symbol))
    }
  ```

  이러한 구현의 단점 : enum 상수끼리 code 공유하기 어려워진다.

  Use enums any time you need a set of constants whose members are known at compile time.

Item35. Use Instance Fields Instead of Ordinals...


