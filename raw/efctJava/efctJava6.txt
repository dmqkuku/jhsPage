--------------------------------------------------------

Chap6. Enums and Annotations.

Item34. Use enums instead of int constants.
 -> int 상수를 거의 무조건 쓰지 말고. enum 사용하자~
 -> COOKIE_MAX_AGE 같은 것처럼 하나만 달랑 있으면 상수 사용하는게 나을수도.
 -> 그러나 Http Status Code 같은 경우에는 enum 쓰는게 낫다.

  int 상수의 단점 중 하나는. 서로 전혀 다른 논리적 카테고리에 속한 상수끼리 연산이 가능
  int 상수의 단점 중 하나는 printable string으로 바꿀 방법이 없다.

  "Java Enum : 각 Enum constant당 하나씩 인스턴스를 export하는 class" -> 일반화된 싱글톤임
  "Complie time safety" 보장해준다.

  rich enum type... <- 메서드, 필드 구현 가능.  <- 필드는 final이 된다. public일 수 있으나 private으로 두고, public accessor를 두는 게 낫다.

  enum을 top-level class로 구현하고. 만약 특정 class와 tight associated되어 있다면 member class로 해라~

  만약에 만약에 각 enum 상수마다 다른 동작을(method 구현) 보이도록 하고 싶다면
  ```
    public enum Opertaion {
        PLUS, MINUS;
        public double apply(double x, double y){
            switch(this){
                case PLUS:
                case MINUS:
            }
        }
    }
  ```
  이거 (fragile한 코드) 대신에

  ```
    public enum Operation{
        public abstract double apply(double x, double y);
        PLUS {
            public double apply(double x, double y){
                return x + y;
            }
        }
        .
        .
        .
    }
  ```
  이렇게 구현할 수 있다. constant-specific class body가 가능!!!
  <- constant-specific method implementations.이라고 부름

  enum type은 자동적으로 생성된 valueOf(String)메서드를 가져서. cosntant'name => constant 로 바꿔줌.
  만약에 enum type의 toString을 override한다면 fromString 메서드를 작성하는 것을 고려하자
  ```
    private static final Map<String, Operation> stringToEnum = 
        Stream.of(values()).collect(toMap(Object::toString, e->e)); //????

    public static Optional<Operation> fromString(String symbol){
        return Optional.ofNullable(StringToEnum.get(symbol))
    }
  ```

  이러한 구현의 단점 : enum 상수끼리 code 공유하기 어려워진다.

  Use enums any time you need a set of constants whose members are known at compile time.

Item35. Use Instance Fields Instead of Ordinals...

  모든 enum은 내재적으로 단일 int 값과 연관되어 있다.
  모든 enum은 Ordinal 메서드를 가지고 있다.
  이 ordinal메서드는 숫자 순서를 리턴하게 된다. 
  이를 abuse하려는 욕심이 생길 수 있다.
  ```
     public enum Ensemble{
         SOLO, DUET
         pubilc int numberOfMusicians{return ordinal() + 1;}
     }
  ```
총체적 난국. 만약 순서가 바뀌면 fragile!
대신 다음을 고려하라!
```
    public enum Ensemble{
        SOLO(1), DUET(2), Double_Quartet(8)
        private final int numberOfMusicians;
        Ensemble(int size) {this.numberOfMusicians = size;}
        pubilc int numberOfMusicians(){return numberOfMusicians;}
    }
```

Item36. Use EnumSet instead of bit fields.
```
    public class Text{
        public static final int STYLE_BOLD = 1 << 0;
        public static final int STYLE_ITALIC = 1 << 1;
        .
        .
        .
    }
    .
    .
    .
    text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```
int constant의 단점을 그대로 지닌다.
출력시 알아보기 힘들고? <- 이방식에 숙련된 사람에게는 문제 없을듯
모든 요소를 쉽게 iterate할 수 없다.
*애초에 자바에는 unsigned가 업구
API만들때. 최대 비트 수와 그에 따른 타입 종류를 파악해야 한다? <- int long. <- 어거지인듯.


->EnumSet사용하자. Set의 일종!
```
public class Text{
    public enum Style {BOLD, ITALIC, ...};
    public void applyStyles(Set<Styles) styles){...}
}
.
.
.
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

이건 좀 논란의 여지가 있을 듯.

Enum에 메서드와 필드를 막 때려박는 것에는 논란의 여지가 있다.

Item37. Use EnumMap instead of ordinal indexing.

Item38. Emulate Extensible enums with interfaces.

Item39. Prefer Annotations to naming patterns.

naming pattern -> 예를들어. @Controller 어노테이션 대신 HomeController라고 명명하고 뒤에 붙은 Controller를 이용하여
스프링이 Controller를 찾는다고 생각해보자~

-> 오탈자 -> 조용한 failure
-> class명을 Controller라고 지으라고 했지만, 모르고 메서드나 필드명을 Controller라고 지을수 있다.
-> 프로르맹 요소를 매개변수로 전달할 방법이 마땅히 없다. 뒤에 덕지 덕지 붙이면? 아주 더러워진다.

애너테이션 선언에 사용하는 애너테이션 == meta annotation.
@Test 의 @Retention(RetentionPolicy.RUNTIME) -> 에너테이션이 유지되는 스코프?
         @Target(ElementType.METHOD) -> 에너테이션 달 수 있는 곳

TODO:
Annotation 구현해보자~
.
.
.

Item 40. @Override Annotation을 일관되게 사용하라.

@Override -> Complier와 IDE에게 힌트!!
overridng하는 게 아니라. 다중 정의를 해놓고 나중에 왜 안되! 이럴 가능성!
따라서 abstract class나 interface를 상속하는 경우 . 자식 클래스에서 오버라이딩하는 모든 메서드에 @Override.

Item 41. Use Marker Interfaces to define types.
아무런 메서드도 가지지 않은 인터페이스로. 구현하는 클래스로 하여금. 사용자가 "아 이런 특성을 가지고 있구나"라고 인지하도록 쓰인다.
Marker annotation이 존재하므로 Marker Interfaces는 필요없다?
-> 비교해 보았을 때. 두가지의 장점이 존재한다.
-> 1. Marker interface define types.! -> ex) Serializable. 
-> 2. more Precise targeting! -> Marker Annotation은 어떠한 클래스/ 인터페이스에 적용 가능하다. 그에 반하여 marker interface는...????

언제 marker annotation을 쓰고. 언제 marker interface를 사용하는가?
-> 만약에 marker가 클래스나 인터페이스이외에도 사용된다면? -> annotation
-> 만약 클래스나 인터페이스에만 사용된다면 -> 이 마킹이 된 객체만 사용할 메서드들을 작성할 일이 있을경우! -> interface;





