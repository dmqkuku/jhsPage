Scala 3.1

var / val

Array : Mutable
List : Immutable

스칼라는 연산자 오버로딩을 지원하지 않는다. 대신 + - * ::: 등을 메서드이름으로 허용한다.

튜플 : 여러 다른 타입의 요소를 포함 가능한 Immutable. 
```scala
val tupleExample = (11, 12, 13)
```

집합(Set). 맵(Map)
-> Immutable과 Mutable 둘다 제공해줌.
```
var jetSet = Set("Boing", "Airbus")
jetSet += "Lear"
```
Lear가 추가된 새로운 Set 인스턴스를 리턴!
```
val jetSet2 = Set("Boing", "Airbus")
jetSet2 += "Lear" // 불가능!.
```

```
val query = jetSet.contains("Boing")
jetSet.contains("Cessna")
```
Mutable set의 경우
```
import scala.collection.mutable
val movieSet = mutable.Set("Spotlight", "Moonlight")
movieSet += "Parasite"
```

Map의 경우
```
val romanNumeral = Map(
    1 -> "I",
    2 -> "II"
    3 -> "III"
    4 -> "IV"
)
val four = romanNumeral(4)
```
Mutable Map
```
val treasureMap = mutable.Map.empty(Int, String)
treasureMap += (1 -> "Go to Island")
treasureMap += (2 -> "Find big X on ground")
treasureMap += (3 -> "Dig")
```

val <- functional styles...

====================================================================================

클래스는 객체에 대한 청사진이다.

```
class ChecksumAccumulator:
    val sum = 0 //field
    var m_sum = 0
    private val p_sum = 0
    def add(b : Byte) : Unit =
        b = 1   // error!
        sum += b
    def checksum() : Int = 
        ~(sum & 0xFF) + 1

var acc = new ChecksumAccumulator
```

싱글톤 객체
-> static 멤버가 안되여...
클래스 대신 Object키워드 사용~
```
object ChecksumAccumulator
```

Companion object -> 동료 객체... === 클래스 이름과 같은 이름을 갖는 싱글톤 객체~
클래스와 싱글톤 객체가 같은 파일안에 있을 때 서로 프라이빗에 접근 가능

```
class singleton:
  val sum = 0
  var m_sum = 0
  def add(b : Byte) : Unit = m_sum += b
  def checksum(): Int = ~(sum & 0xFF) + 1

import scala.collection.mutable
object singleton:
  private val cache = mutable.Map.empty[String, Int]
  def calculate(s : String) : Int =
    if cache.contains(s) then
      cache(s)
    else
      val acc = new singleton
      for c <- s do
        acc.add((c >> 8).toByte)
        acc.add(c.toByte)

      val cs = acc.checksum()
      cache += (s -> cs)
      cs
```

단독객체. Standalone Object

---------------------------------------------------

case class. 케이스 클래스.

```
case class Person(name : String, age : Int)
```

=========================================

Scala application

1. @main

2. 또다른 방법 : 
  -> 단독 싱글톤 객체에 main 이름을 가진 메서드 정의

Object StartPoint:
  main(args : Array[String]) : Unit = 
    .
    .
    .

3. App trait 파생 객체

object Main extends App:
  .
  .
  .

----------------------------------------------------

1. 기본타입(Basic Type) Byte, Short, Int, Long, Char, String, Float, Double, Boolean

2. 리터럴(literal) 
   상수(Constant)
   -정수형 : default -> Integer
   -실수형 : default -> Double    
   --> 10진수/ 16진수 둘다 사용가능
    1000000000 == 1_000_000_000
    35L
    1.2345e1 == 12.345

   -문자형 : char 'A' '가'(유니코드 지원), '\u9041'
   -이스케이프 시퀀스(escape sequence) \b \n \t \f \r \" \' \\
   -문자열 : "Str"
   -순문자열(raw string) : """I am Raw"""
   -불리안(boolean) : true / false
   -String Interpolation : s"Hello $name"
                           s"The amswer is ${3 + 7}"

3.  연산자 = 메서드!!!
  1 + 2 ===> 1.+(2)
  "Hello World".indexOf('o') ==> "Hello World" indexOf 'o'
 
5. 산술 연산.
  + - * / %
6. 관계 연산
  == > < <= >= --> Boolean.

8. 객체 동일성(Object Equality)
  List(1, 2, 3) == List(1, 2, 3) <- True!!!!

================================================

함수형 객체.

 변경할 수 있는 상태를 갖지 않는 객체. 즉 var 필드가 없음.

ex ) 유리수 (Rational Number) => n (numberator) : 분자 / d (denominator) : 분모
```
class Rational(n: Int, d : Int): <- 클래스 매개변수. class parameter
  require(d != 0) <- 사전 조건 체크...
```
여기서 클래스 이름은 생성자가 되고 Primary Constructor라고 불린다.

클래스 파라미터는 기본적으로 private...

클래스 생성시 new 키워드 없이도 생성 가능...

보조 생성자를 둘 수 있다. Auxilary Constructor. -> 주 생성자가 아닌 모든 다른 생성자.
def this(n : Int) = this(n, 1)

Rational + 3 //valid

3 + Rational //invalid

extension Method 정의가능
```
extension(x : Int)
  def + (y : Rational) = Rational(x) + y
```

========================================================

내장 제어 구조.

