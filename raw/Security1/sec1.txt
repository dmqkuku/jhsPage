1

# Security by Pope Kim.
-------------------------

암호화 Encryption이란. 평문 -> 암호문. 암호문은 "특정 정보"가 있어야 해독 가능.

암호학적 해시 알고리듬의 목적은 해시 -> 원문 즉 원문 복구를 불가능하게 만드는 것이 목적,

암호화 알고리즘은 원문 복구를 허용.

대칭 키 암호화(Symmetric key Encryption)
-> 암호화 복호화에 동일한 키 사용.

비대칭 키 암호화 (Asymmetric key Encryption)
-> 암호화와 복호화 에 사용하는 키가 다름.
-> 공개 키 암호화 라고도 함.

-----------------------------

대칭 키 암호화...

키를 수신자와 송신자가 공유하고 있어야 한다....
즉 비밀스럽게 송신자에게 발급자가 키를 알려주고. safe하게 지켜야 한다. <- 단점!!

A XOR B = C.
C XOR B = A.

스트림 암호(Stream cipher) -> 한번에 1바이트씩 암호화. 각 바이트에 적용하는 키가 달라야 안전. <- 시드를 이용한 난수로 생성하는게 일반적.

블록 암호(Block Cipher) -> 정해진 블록 크기(64비트 이상 = 8 바이트 이상) 씩 한 번 에 암호화. 각 블록에 사용하는 키가 동일.

WIFI 비밀번호도 일종의 대칭 키.
스마트폰과 공유기 사이에 통신시 이 키로 암호화.

DES(Data Encryption Standard)
AES(Advanced Encryption Standard)
 -> 일급 비밀 용으로 승인한 유일한 공개 암호화 알고리즘. 블록 크기 : 128비트.
 키 길이 : 128, 192, 256 비트.
 라운드 :  10 ,  12  ,14

 AES -> 16바이트 씩 읽는다.
 16바이트를 4 * 4 행렬로 재배치. -> 행렬 연산 수행.

 1. 키 확장 
    대칭 키로부터 각 라운드에 사용할 여러 키를 생성(라운드 키)
    AES Key Schedule.
    총 라운드 + 1개
    라운드 키는 대칭키의 길이와 상관없이 128 비트. == 16 바이트.
 2. 0라운드 : 라운드 키 더하기
    라운드 키를 원문에 더함. 더한다 == XOR(배타합)
    어떻게 16진수 끼리 배타합 쉽게 계산??? -> 다른 비트 연산도..
    어떻게 8진수 끼리 배타합 쉽게 계산??? -> 다른 비트 연산도..

    -> 원본 메시지 숨기는 목적.
 3. 9/11/13라운드 : 바이트 대체. 행 이동. 열 섞기. 라운드 키 더하기
    바이트 대체 -> 각 바이트를 룩업 테이블을 이용해 다른 바이트로 대체.(SubBytes라고 부름) (AES S-Box가 테이블)
               -> 선형적인 변환(연산)이 아니라 단순 사칙. 비트 연산으로 찾을 수 없다. ==> 흩뿌려놓기. 혼란(confusion) 효과.
    행 이동 -> 각 행을 다르게 ShiftRows. 
            1 행 : 이동 없음
            2 행 : 1
            3 행 : 2
            4 행 : 3 -> 확산(diffusion) 효과
    열 섞기 -> 각 열의 4 바이트를 선형적으로 변환. 
            -> 행렬 벡터 곱을 사용? 
            + 는 XOR.
            X 는 특별한 비트 곱셈.
    
 4. 최종 라운드 : 바이트 대체. 행 이동. 라운드 키 더하기.

-------------------------------------------------------

 비대칭 키 암호화....

 두 키 . 공개키와 비밀키는 특수한 관계가 존재하여. 
 한 키로 암호화한 메시지를 다른 키로 복호화 가능.
 
1. 보통 공개키를 가진 사람이 암호화한 메시지를 송신하고
비밀키를 가진 사람이 수신한다.

2. 전자 서명. 메시지 송신자가 비밀키로 암호화. 올바름을 증명. 암호화폐에서 이 방식 사용.

-> RSA. 공개키/비밀 키 쌍을 만드는 것이 아주 쉬움.

암호문을 거듭제곱하고 나머지 연산하면 원문이 돌아옴...

서로 다른 소수의 곱 = 합성수 그 합성수의 두 인수는 소수임..

두 소수를 곱한 합성수에서 그 소수들을 찾는 것은 휠씬 어려움...

NIST에서 권하는 RSA 키 길이
2002 기준 1024 비트
2015 기준 2048 비트
2^1024 ~~ 308자릿수.

비밀키 = 아주 큰 소수 p, q
공개키 = 합성수 n (p * q)

-> 공개키로부터 비밀키를 찾아내기 아주 힘듬.

p, q와 특수한 관계. 서로 특수한 관계를 가지는 e, d
e : 공개키의 두번째 요소
d : 비밀키의 두번째 요소

( m ^ e ) ^ d === m (mod n)
de === 1 (mod Lambda(n))

a tripleEqual b(mod n) 은 a = b (mod n)과 다름
mod n이 좌항 우항 모두 적용이라고 봐야 한다. -> n은 p * q / m은 원문(plaintext)
a = xn + c
b = yn + c
a - b = (x - y)n

-> a - b = kn
-> a mod n = b mod n

1. 매우 큰 소수 p, q를 찾는다.
    -> 매우 큰 랜덤 수를 뽑음
    -> 소수인지 판별 : 확률적 알고리즘을 사용. 밀러-라빈 소수 판별법
        -> 소수를 구하는 법.
            https://rebro.kr/46
            1. N을 2 ~ N-1까지 나누기.
                -> N = p * q일때 한 쪽은 반드시 loot(N)이하이다. 따라서 loot(N)까지만 나누어도 판별 가능.
            2. 에라토스테네스의 체
                A배열에 대해서 2 ~ N까지 돌면서 i * j인덱스에 해당하는 곳에 1을 넣어주고. 끝까지 돌리면. 0만 소수이다.
            3. 밀러-라빈 소수 판별법. -> 확률적으로 소수인지 판별. (매우 큰 정수 long long일때는 정확)
                -> 페르마의 소정리
                    -> a ^ p === a (mod p)
                    -> a ^ (p -1) === 1(mod p) if a % p != 0;
                -> 보조정리 2
                    -> x ^ 2 === 1 (mod p)이면, x === -1(mod p) or x === 1 (mod p) 즉
                    x ^ 2 - 1이 p의 배수일때, x + 1혹은 x -1이 p의 배수가 된다.
                    
                    N이 2가 아닌 소수일때 N -1은 짝수. N - 1을 홀수가 될 때까지 나눠주면
                    N - 1 = d * 2 ^ r;
                    여기서 페르마의 소정리
                    a ^ (N-1) === 1 (mod N),
                    a ^ (d * 2 ^ r) === 1 (mod N),
                    a & (d * 2 ^ (r - 1)) ^ 2 === 1 (mod N),
                    이 과정을 계속하면
                    a ^ (d * 2) = 1 (mod N)
                    즉 N이 소수이고, N 보다 작은 양의 정수 a에 대하여...
                    a ^ d === 1 (mod N)
                    a ^ (d * 2 ^ r) === -1 (mod N)

                    N은 아마도 소수
                    int 범위에서는 2, 7, 61을 통과해야 소수이고
                    long long 범위에서는 37 까지의 소수들에 대해 통과해야 한다.

2. p, q를 곱해 n을 만든다.
   67 , 53 가정 -> 3551
3. p, q과 수학적 관계를 가지는 e를 찾는다.
    n의 카마이클 수를 구한다.
    lambda(n) = lcm(p-1, q-1) : lcm은 최소공배수.
    1 < e < lambda(n) 이고 lambda(n)과 서로소인 e를 찾는다.
    서로소 : 공약수가 1뿐인 정수
    조건만 만족하면 아무거나 상관없음.
4. e오 특수한 관계인 d를 찾는다.
    de = 1 (mod lambda(n))
    확장 유클리드 호제법 (https://baeharam.github.io/posts/algorithm/extended-euclidean/)
        -> 유클리드 호제법 ->  GCD(A, B) = GCD(B, r) (A === r (mod B))

        -> 배주 항등식(Bezout's identity)
            GCD(a, b) = d라고 할때
            ax + by = d를 만족하는 x y가 존재.
            d는 정수 x, y에 대하여 ax + by로 표현할 수 있는 가장 작은 정수이다.
            ax + by로 표현될 수 있는 모든 정수는 d의 배수이다.

        GCD(a, b) = c일때 , ax + by = c의 해 (x, y)를 구하는 것이 요점.
        a = b * q0 + r1
        b = r1 * q1 + r2
        r1 = r2 * q2 + r3
        .
        .
        .

    e와 lambda(n)이 서로소이면 반드시 위 조건을 만족하는 d가 존재.

암호화
    m ^ e % n = c;
    m은 원문으로 반드시 숫자여야 하고 m < n이어야 하며
    m >= n이라면 패딩?등을 통해 변환하여 조건 맞출것.

복호화
    c ^ d % n = m;
    


