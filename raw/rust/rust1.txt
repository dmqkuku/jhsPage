Rust 의 컨셉...
변수. 기본 타입. 함수. 주석. 흐름 제어.

1. 변수
 기본적으로 모든 변수는 immutable.
 변수에 mut을 붙여 선언함으로써 mutable로 만들 수 있다.
 그러면
 ```
fn main() {
    println!("Hello, world!");
    let x = 32;
    println!("{}", do_something(x));
    println!("{}",x)
}
fn do_something(mut x : i32) -> i32{
    x = 144; //가능?
    x
}
 ```
 즉 메서드 파라미터에 재할당할 수 있고. 리턴도 가능하다... -> 그러나 원본이 바뀌지 않는다. 일단 원시값에선...
 스트럭트에서는?
 ```
use std::fmt;
use std::fmt::Formatter;

fn main() {
    println!("Hello, world!");
    let x = 32;
    let p = Data{data : x};
    println!("{}", do_something(p));
    println!("{}", x);
}
fn do_something(mut x : Data) -> Data{
    x = Data{data : 144};
    x
}
struct Data {
    data : i32
}
impl fmt::Display for Data{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_str(&(self.data).to_string())
    }
}
 ```
 rust is [pass by value] or [pass by reference]?
참고: https://blog.ryanlevick.com/rust-pass-value-or-reference/#:~:text=Rust%20is%20strictly%20a%20pass,Rust%20are%20first%20class%20citizens.

러스트는 엄격히. pass-by-value이고, 러스트에서 reference는 일급 citizen이다. 즉 함수로 값으로서 넘겨진다.
```
fn main() {
  let array_main: [Vec<u8>; 3] = [vec![1], vec![2, 4], vec![]];
  print(array_main);
}

fn print(array: [Vec<u8>; 3]) {
  for e in array.iter() {
    println!("{:?}", e)
  }
}
```
Vector를 growable 배열이라고 생각. 사실은 하나의 struct이다.
따라서 struct copy가 발생했다고 생각할 수 있는데.
사실은 그렇지 않다.
Vecs가 reference이므로 카피될 경우. 하나의 값에 두개의 포인터가 있는 상황이 발생하게 된다.
따라서 이 경우 refernece가 "이동"! 하고 main의 array_main은 이동한 이후에는 사용할 수 없게 된다.

??
https://www.tutorialspoint.com/rust/rust_borrowing.htm#:~:text=It%20is%20very%20inconvenient%20to,to%20the%20original%20owner%20entity.
tutorialspoint에서는 빌려간 소유권이 반환된다고 한다?

아하~
소유권을 이전하는 것과 빌려가는 것은 다르다!
빌리리면~ &을 사용한다!

mut &은 오로지 mut var에만 사용 가능하다!!

mut & 로는 다음과 같은 짓이 가능함~
```
fn main() {
   let mut name:String = String::from("TutorialsPoint");
   display(&mut name); 
   //pass a mutable reference of name
   println!("The value of name after modification is:{}",name);
}
fn display(param_name:&mut String){
   println!("param_name value is :{}",param_name);
   param_name.push_str(" Rocks"); 
   //Modify the actual string,name
}
```
결과 :  mut String -> 소유권 잠시 빌림 -> 빌린 곳에서 변경 -> 변경이 유지된 채 소유권이 반환됨.
```
param_name value is :TutorialsPoint
The value of name after modification is:TutorialsPoint Rocks
```


약간 특이한 개념 constant왜냐면. 이미 모든 변수가 기본적으로 mutable하면 따로 상수가 필요없는 것 아닌가?
1. constant와는 mut 혼용 불가능. 즉 항상 immutable이다.
2. 오로지 constant expression의 결과만이 할당될 수 있따. runtime에 결정되는 값들은 할당될 수 없따.


짜증나는 개념 Shadowing.(헷갈리기 딱 좋다.)
같은 이름으로 변수를 다시 선언할 수 있다.
```
    let x = 5;
    let x = x + 1;
```
이따위 지거리가 가능 헐~ 왜???

```
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
결과 : 12 
     : 6
```
심지어 다른 타입으로 Shadowing도 가능!!!
```
let l = " ";
let l = l.len(); // 가능!
```
```
let mut l = "  ";
l = l.len();    // 불가능!!!
```

f32 -> Single Precision.
f64 -> Double Precision. <- what is it?

Char -> Unicode.
[Storing UTF-8 Encoded Text With String]
Rust에서 String 타입(str이나 &str이 아님!)
growable, mutable, owned, UTF-8 encoded String type.


